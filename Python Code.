

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import random
import math
# import sympy
# from sympy import mod_inverse

# FUNCTIONS!
 

def pseudoprime(n1 = 1000000, n2 = 100000000, k = 1000):
    p = random.randint(n1, n2)
    pseudo_prime = False
    while not pseudo_prime:
        for i in range(k):
            j = random.randint(2, p)
            if pow(j, p-1, p) > 1:
                p = random.randint(n1, n2)
                break
        pseudo_prime = True

    return p

# Testing primality 
def testPrime_brute_force(p = 10):
    if (p == 2):
        return True
    else:
        for b in range(2, math.floor(math.sqrt(p))):
            if math.gcd(p, b) > 1:
                return False
            else:
                continue
        return True
    
#Generating the two primes 
def generate_prime():
    while(True):
        pseudo_prime = pseudoprime()
        if(testPrime_brute_force(pseudo_prime)):
            break

    return pseudo_prime

"""
#old code
def generate_large_prime(bits=100):
    while True:
        candidate = random.getrandbits(bits)
        if candidate % 2 == 0:
            candidate += 1  
        if sympy.isprime(candidate):
            return candidate

# Function to generate two large prime numbers
def generate_two_large_primes(bits=100):
    prime1 = generate_large_prime(bits)
    prime2 = generate_large_prime(bits)
    return prime1, prime2
"""

#Generating phi
def gen_phi(prime1,prime2):
    phi = (prime1-1)*(prime2-1)
    return phi

#Generating n
def gen_n(prime1,prime2):
    n = prime1*prime2
    return n

# Function to calculate the greatest common divisor (GCD) using Euclid's algorithm 
def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a%b)
    
# Find an 'e' relatively prime to phi 
def find_e(phi):
    e = random.randint(2, phi)
    while gcd (e, phi) != 1:
        e = random.randint(2, phi)
    return e

#Extended GCD Form for efficiently determing the private key 
def extendedGCD(a=1, b=1):
    if (b==0):
        return (1,0,a)
    (x,y,d) = extendedGCD(b,a%b)
    
    return y, x-a//b*y, d

#Generating d  
def generate_private_key(e,phi):
    x = extendedGCD(e,phi)
    d = x[0] % phi

    return d

#Encryption
def encrypt_message(message, e, n):
    message = message.upper()
    encrypted_message = []
    for x in message:
        x = pow(ord(x),e,n) 
            
        encrypted_message.append(x)

    return encrypted_message


#Decryption
def decrypt_message(encrypted_data, d, n):
    decyphered_message = ''
    var = 0

    for x in (encrypted_data):
        var = pow(x,d,n)
        
        if(var == 32):
            decyphered_message += chr(var)
        else:
            var = (var-65)%26
            decyphered_message += chr(var+65)

    return decyphered_message

signatures_received = {}

def sign_message(message, d, n):
    convertmessage = message.encode()
    codemessage = int.from_bytes(convertmessage,'big')
    S = pow(codemessage, d, n)
    return S

def authenticate_signature(Signature_list, e, n, message):
    codemessage = int.from_bytes(message.encode('utf-8'), 'big')
    for S in Signature_list:
        result = pow(S, e, n)
       
        if result == codemessage:
            return True  
        else:
            return False 

"""
#OLD CODE
#Generating digital signature 
def signature(message, d, n):
  """  

"""
# Function to calculate modular exponentiation (used for encryption and decryption)
def mod_pow(base, exponent, modulus):
    result = 1
    while exponent > 0:
        if exponent % 2 == 1:
            result = (result * base) % modulus
        base = (base * base) % modulus
        exponent //= 2
    return result

# Function to generate RSA keys
def generate_rsa_keys(bits=100):
    prime1, prime2 = generate_two_large_primes(bits)
    n = prime1 * prime2
    phi = (prime1 - 1) * (prime2 - 1)
    e = find_e(phi)
    d = mod_inverse(e, phi)
    public_key = (n, e)
    private_key = (n, d)
    return public_key, private_key

# Function to encrypt a message
def encrypt_message(public_key, message):
    n, e = public_key
    encrypted_message = [mod_pow(ord(char), e, n) for char in message]
    return encrypted_message

# Function to decrypt a message
def decrypt_message(private_key, encrypted_message):
    n, d = private_key
    decrypted_message = ''.join([chr(mod_pow(char, d, n)) for char in encrypted_message])
    return decrypted_message

# Function to sign a message
def sign_message(private_key, message):
    n, d = private_key
    signature = [pow(ord(char), d, n) for char in message]
    return signature

# Function to verify a digital signature
def verify_signature(public_key, message, signature):
    n, e = public_key
    decrypted_signature = [pow(char, e, n) for char in signature]
    original_message = ''.join([chr(char) for char in decrypted_signature])
    return original_message == message
"""
# MENU/USER INPUT

prime1 = generate_prime()
prime2 = generate_prime()

phi = gen_phi(prime1, prime2)
e = find_e(phi)
n = gen_n(prime1,prime2)
d = generate_private_key(e,phi)

cipher_list = []
#main menu
print("RSA keys have been generated.")
while True:
    
    print("Please select your user type:")
    print("1. A public user")
    print("2. The owner of the keys")
    print("3. Exit program")

    user_type = input("Enter your choice: ")
    print()

    if user_type == "1":
        #public user menu
        while True:
            print("As a public user, what would you like to do?")
            print("1. Send an encrypted message")
            print("2. Authenticate a digital signature")
            print("3. Exit")

            choice = input("Enter your choice: ")
            print()

            if choice == "1":
                #call the function to send an encrypted message
                message = input("Enter a message: ")
                cypher = encrypt_message(message,e,n)
                cipher_list.append(cypher)
                print("Message encrypted and sent.")
                print()

            elif choice == "2":
                
                if signatures_received:
                    #display available signatures
                    print("The following messages are available:")
                    for index, message in enumerate(signatures_received.keys(), start=1):
                        print(f"{index}. {message}")
                    
                    #ask the user to select a signature to authenticate
                    selected_index = int(input("Enter your choice: ")) - 1
                    selected_message = list(signatures_received.keys())[selected_index]
                    
                    #retrieve the corresponding signature S from the dictionary
                    S = signatures_received[selected_message]

                    #call the authentication function
                   
                    is_signature_valid = authenticate_signature(S, e, n, selected_message)

                    if is_signature_valid:
                        print("Signature is valid.")
                    else:
                        print("Signature is not valid.")
                        signature_choice = input("Enter your choice: ")

                else:
                    print("There are no signatures to authenticate.")
                
                """for message, count in signatures_received.items():
                    print(f"Message '{message}'")"""
                
            elif choice == "3":
                break 
            
    # Option 2 - The owner of the keys
    elif user_type == "2":
        while True:
            print("As the owner of the keys, what would you like to do?")
            print("1. Decrypt a received message")
            print("2. Digitally sign a message")
            print("3. Show the keys")
            print("4. Generating a new set of keys")
            print("5. Exit")

            o_choice = input("Enter your choice: ")
            print()

            if o_choice == "1":
                if(len(cipher_list) == 0):
                        print("No messages to decrypt yet")
                        print()
                else:
                    print("The following messages are available:")
                    ind = 1
                    for x in cipher_list:
                        print(ind, '. ( Message Length: ', len(x),' )')
                        ind += 1
                        
                    message_choice = int(input("Enter your choice: "))
                    print()

                    decrypt = decrypt_message(cipher_list[message_choice - 1], d, n)
                    
                    print("Decrypted message:")
                    print(decrypt)
                    print()

            elif o_choice == "2":
               
                message = input('Enter a message: ')
                S = sign_message(message, d, n)  
               
                if message not in signatures_received:
                    signatures_received[message] = [S]
                else:
                    signatures_received[message].append(S)
                print("Message signed and sent.")
                print()

            elif o_choice == "3":
                
                print("Key information:")
                
                print('Public Key: (',e,', ', n,' )')
                print('Private Key: ( ', d, ' )')
                print()

            elif o_choice == "4":
                print("Generating...")
                e = find_e(phi)
                d = generate_private_key(e, phi)
                print()
                
            elif o_choice == "5":
                break  

    elif user_type == "3":
        print("Bye for now!")
        break  

    else:
        print("ERROR: Invalid choice!")
        print()

       

